# Course
This example is based on the function `assert`.

When used incorrectly, `assert` will evaluate the value received. This behaviour can be used to gain code execution.

By injecting a `single quote` or `double quote` (depending on the way the string was declared), we can see an error message indicating that PHP tried to evaluate the code:
```php
Parse error: syntax error, unexpected T_ENCAPSED_AND_WHITESPACE in /var/www/codeexec/example4.php(4) : assert code on line 1 Catchable fatal error: assert(): Failure evaluating code: 'hacker'' in /var/www/codeexec/example4.php on line 4
```

Once we have broke the syntax, we need to try to reconstruct it correctly. We can try the following: `hacker'.'`. We can now see that the error message has disappeared.

Now that we know how to finish the syntax to avoid errors, we can just inject our payload to run the function `phpinfo()`: `hacker`.`phpinfo().'` and we get the configuration of the PHP engine in the page.

Finally, we can use system to score.

This trick will no longer work with most PHP 7 and all PHP 8 applications. Extract from the the PHP documentation for `assert()`:

`assert()` will no longer evaluate string arguments, instead they will be treated like any other argument. assert($a == $b) should be used instead of assert('$a == $b'). The assert.quiet_eval php.ini directive and the ASSERT_QUIET_EVAL constant have also been removed, as they would no longer have any effect.